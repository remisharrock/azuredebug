<!DOCTYPE html>
<html>
<head>
    <title>Voice Bot Client</title>
</head>
<body>
    <button id="connect-daily">Connect Daily</button>
    <button id="connect-smallwebrtc">Connect SmallWebRTC</button>
    <p id="status"></p>
    <audio id="audio" autoplay></audio>
    <script type="module">
        import { PipecatClient } from "https://esm.run/@pipecat-ai/client-js@latest";
        import { DailyTransport } from "https://esm.run/@pipecat-ai/daily-transport@latest";

        const connectDailyBtn = document.getElementById('connect-daily');
        const connectSmallBtn = document.getElementById('connect-smallwebrtc');
        const audio = document.getElementById('audio');
        const status = document.getElementById('status');
        let pcClient = null;
        let peerConnection = null;

        const setStatus = (message, isError = false) => {
            status.textContent = message;
            status.style.color = isError ? 'red' : 'green';
        };

        const cleanupPipecat = async () => {
            if (!pcClient) {
                return;
            }

            try {
                if (typeof pcClient.disconnect === 'function') {
                    await pcClient.disconnect();
                } else if (typeof pcClient.destroy === 'function') {
                    await pcClient.destroy();
                }
            } catch (error) {
                console.warn('Pipecat disconnect warning:', error);
            }

            pcClient = null;
        };

        const cleanupPeer = () => {
            if (peerConnection) {
                peerConnection.getSenders().forEach((sender) => sender.track?.stop());
                peerConnection.close();
                peerConnection = null;
            }
        };
        
        connectDailyBtn.onclick = async () => {
            cleanupPeer();
            await cleanupPipecat();
            setStatus('Connexion Daily en cours…');

            try {
                const response = await fetch('/connect', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ transport_type: 'daily' })
                });

                if (!response.ok) {
                    const errorBody = await response.json().catch(() => ({}));
                    throw new Error(errorBody.detail || response.statusText);
                }

                const { dailyRoom, dailyToken } = await response.json();

                const handleBotAudio = (track, participant) => {
                    if (participant?.local || track.kind !== 'audio') {
                        return;
                    }

                    const mediaStream = new MediaStream([track]);
                    audio.srcObject = mediaStream;
                    audio.play().catch((error) => console.warn('Playback warning:', error));
                };

                pcClient = new PipecatClient({
                    transport: new DailyTransport(),
                    enableMic: true,
                    callbacks: {
                        onTrackStarted: handleBotAudio,
                    },
                });

                await pcClient.connect({ url: dailyRoom, token: dailyToken });
                setStatus('Connecté via Pipecat Daily');
            } catch (error) {
                await cleanupPipecat();
                setStatus(`Erreur Daily: ${error.message ?? error}`, true);
                console.error('Daily connection error:', error);
            }
        };

        connectSmallBtn.onclick = async () => {
            await cleanupPipecat();
            cleanupPeer();
            setStatus('Connexion SmallWebRTC en cours…');

            const pc = new RTCPeerConnection();
            peerConnection = pc;

            const playbackStream = new MediaStream();
            audio.srcObject = playbackStream;

            pc.addTransceiver('audio', { direction: 'sendrecv' });
            pc.addEventListener('track', (event) => {
                if (event.track.kind === 'audio') {
                    playbackStream.addTrack(event.track);
                }
            });

            try {
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                const response = await fetch('/offer', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ sdp: offer.sdp, type: offer.type })
                });

                if (!response.ok) {
                    const errorBody = await response.json().catch(() => ({}));
                    throw new Error(errorBody.detail || response.statusText);
                }

                const answer = await response.json();
                const remoteDesc = { type: answer.type ?? 'answer', sdp: answer.sdp };
                await pc.setRemoteDescription(remoteDesc);
                setStatus('Connecté via SmallWebRTC');
            } catch (error) {
                cleanupPeer();
                setStatus(`Erreur SmallWebRTC: ${error.message ?? error}`, true);
                console.error('SmallWebRTC connection error:', error);
            }
        };
    </script>
</body>
</html>